// Rem Attribute VBA_ModuleType=VBAModule
// Option VBASupport 1
import registerWebworker from "webworker-promise/lib/register";

type WindfarmCollisionConfigType = {
  blades: number;
  radius: number;
  pitch: number;
  chord: number;
  bladeForm: [number, number][];
  omega: number;
};
type BirdCollisionConfigType = {
  speed: number;
  length: number;
  wingspan: number;
  flight_type: "flapping" | "gliding";
};
export function pcoll(
  r: number,
  phi: number,
  updown: "up" | "down",
  windfarm: WindfarmCollisionConfigType,
  bird: BirdCollisionConfigType
): any {
  //
  // 'this function evaluates the collision risk at r,phi for up or downwind flight
  // ' r is dimensionless (r/R) and phi in degrees
  // 'assuming flight perpendicular to rotors
  // 'it calls a linear interpolation function to evaluate the chord width at radius r

  // Application.Volatile
  // Application.Calculation = xlCalculationAutomatic
  let result;
  let { blades, radius, pitch, chord, omega, bladeForm } = windfarm;

  let { speed, wingspan, length, flight_type } = bird;

  let F; // As Single
  let multiplier; // As Single
  let direction = updown === "up" ? 1 : -1; // As Integer
  let collidelength1; // As Single
  let collidelength2; // As Single

  const pi = Math.PI;
  phi = (phi * pi) / 180; //'converts degrees to radians

  radius = radius * r; //'converts r to real radius
  chord = chord * interpolate(bladeForm, r); //'interpolates from c/C data for this r
  omega = (omega * 2 * pi) / 60; //             'converts rpm to radians/sec
  pitch = (pitch * pi) / 180; //           'converts degrees to radians

  if (flight_type === "flapping") {
  } else {
    if (flight_type === "gliding") {
      wingspan = wingspan * Math.abs(Math.cos(phi));
    }
  }

  multiplier = (blades * omega) / (2 * pi * speed);

  if (radius === 0) {
    result = 1;
  } else {
    const alpha = speed / (radius * omega);

    collidelength1 = Math.abs(
      direction * chord * Math.sin(pitch) + alpha * chord * Math.cos(pitch)
    );

    if (length > wingspan * alpha) {
      collidelength2 = length;
    } else {
      collidelength2 = wingspan * alpha;
    }
    if (multiplier * (collidelength1 + collidelength2) > 1) {
      result = 1;
    } else {
      result = multiplier * (collidelength1 + collidelength2);
    }
  }
  return result;
}

function interpolate(A: [number, number][], y: number): number {
  // ' this function uses the input value y
  // ' a set of points in range A and corresponding data in range B, both ranges length N
  // ' identifies the pair of points bracketing y in range A first column
  // ' then linearly interpolates to produce a data value appropriate to y from the corresponding second column
  // ' error message if y is less than first point or greater than last point
  // ' assumes that set of points in the first column is increasing

  // Application.Volatile
  // Application.Calculation = xlCalculationAutomatic
  let N = A.length - 1;
  let i: number = 0;
  let p: number;
  let ybottom: number;
  let ytop: number;
  let lower: number;
  let upper: number = A[i + 1][0];

  let result = 0;
  ybottom = A[1][0];
  ytop = A[N][0];
  // 'MsgBox ybottom, 0, "ybottom"
  // 'MsgBox ytop, 0, "ytop"
  // 'If (Y < ybottom Or Y > ytop) Then
  // '    MsgBox Y, vbInformation, "outwith data range" + A
  // 'End If
  do {
    i++;
    lower = A[i][0];
    upper = A[i + 1][0];
  } while (upper < y || i + 1 !== N);

  p = (y - lower) / (upper - lower);
  result = A[i][1] + p * (A[i + 1][1] - A[i][1]);
  return result;
}
// Function pcoll_rav(ByVal rad As Single, updown As String) As Single
// ' integrates around the annulus at radius r/R
// Dim angle As Single
// Dim total As Single
// Dim increment As Single
//
// angle = 0
// total = 0
// increment = 10
//
// If (updown <> "up" And updown <> "down") Then
// MsgBox "not up or down.  Up assumed."
// updown = "up"
// End If
//
// For angle = 0 To (180 - increment) Step increment
// total = total + pcoll(rad, angle, updown)
//
// 'MsgBox angle, vbInformation, "angle"
// 'MsgBox total, vbInformation, "total"
// Next
// pcoll_rav = total * increment / 180
//
// End Function
//
// Function pcollxy(ByVal x As Single, y As Single, updown As String) As Single
// Dim r As Single
// Dim phi As Single
// Dim pi As Single
//
// 'MsgBox x, vbInformation, "x"
// 'MsgBox y, vbInformation, "y"
//
// pi = Application.pi()
// r = (x * x + y * y) ^ 0.5
//
// If y = 0 Then
// If (x >= 0) Then
// phi = pi / 2
// Else
// phi = -pi / 2
// End If
// Else
// phi = Atn(x / y)
// If y < 0 Then phi = pi + phi
// End If
//
// phi = phi * 180 / pi
//
// 'MsgBox r, vbInformation, "r"
// 'MsgBox phi, vbInformation, "phi"
//
// pcollxy = pcoll(r, phi, updown)
// End Function
//
// Function xareasum2(ByVal y As Single) As Single
// 'Gives length of chord at y
//
// If y > 1 Or y < -1 Then
// MsgBox y, vbInformation, "xareasum2: y outwith bounds of circle"
// xareasum2 = 0
// Else
// xareasum2 = 2 * ((1 - y * y) ^ 0.5)
// End If
//
// End Function
//
//
// Function xrisksum2(ByVal y As Single, xinc As Single, updown As String) As Single
// Dim xmax As Single
// Dim imax As Integer
// Dim i As Integer
// Dim risk As Single
// 'Integrates x-symmetrical function pcollxy across chord of circle
//
// If y > 1 Or y < -1 Then
// MsgBox y, vbInformation, "xrisksum2: y outwith bounds of circle"
// xrisksum2 = 0
// Else
// xmax = (1 - y * y) ^ 0.5
// imax = Int(xmax / xinc)
// risk = (pcollxy(imax * xinc, y, updown) / 2 + pcollxy(xmax, y, updown) / 2) * (xmax - imax * xinc)
//
// If imax > 0 Then
// risk = risk + (pcollxy(0, y, updown) / 2 + pcollxy(imax * xinc, y, updown) / 2) * xinc
// i = 1
// Do While i < imax
// risk = risk + pcollxy(i * xinc, y, updown) * xinc
// i = i + 1
// Loop
// End If
//
// xrisksum2 = 2 * risk
// End If
//
// End Function
//
// Function ydistsum(ByVal xinc As Single, yinc As Single, updown As String, flag As Integer) As Single
//
// ' This is a trapezoidal integration of bird density x risk across all values of height y
// '  Height is divided into (2 imax + 1) bands, the lowest being y=-1, the highest y=+1
// '  Height is converted to metres above sea level then used to find bird density at that level
//
// Application.Volatile
// Application.Calculation = xlCalculationAutomatic
//
// Dim i As Integer
// Dim imax As Integer
// Dim total As Single
// Dim npoints As Integer
// Dim y As Single
// Dim radius As Single
// Dim hubheight As Single
// Dim offset As Single
// Dim dy As Single
//
// radius = Range("radius").Value
// hubheight = Range("hubheight").Value
// offset = Range("offset").Value
// npoints = Range("npoints").Value
//
// total = 0
// imax = Int((1 / yinc) + 0.5)
// yinc = 1 / imax
// 'MsgBox imax, vbInformation, "imax"
// 'MsgBox yinc, vbInformation, "yinc"
//
// 'Find bird density at lowest rotor point then calculate risk
// dy = radius * interpolate(npoints, "flightheightdata", -imax * yinc * radius + hubheight + offset)
// If (flag = 1) Then
// total = dy * xareasum2(-imax * yinc) / 2
// Else
// total = dy * xrisksum2(-imax * yinc, xinc, updown) / 2
// End If
//
// 'Find bird density at highest rotor point, then add in risk
// dy = radius * interpolate(npoints, "flightheightdata", imax * yinc * radius + hubheight + offset)
// If (flag = 1) Then
// total = total + dy * xareasum2(imax * yinc) / 2
// Else
// total = total + dy * xrisksum2(imax * yinc, xinc, updown) / 2
// End If
//
// i = -imax + 1
// Do While (i < imax)
//
// '    Find bird density at successive steps in height then add in risk
// dy = radius * interpolate(npoints, "flightheightdata", i * yinc * radius + hubheight + offset)
// If (flag = 1) Then
// total = total + dy * xareasum2(i * yinc)
// Else
// total = total + dy * xrisksum2(i * yinc, xinc, updown)
// End If
// i = i + 1
// Loop
//
// ydistsum = total * yinc
// End Function

// 'Function ydistdiscretesum(ByVal xinc As Single, updown As String, flag As Integer) As Single
//
// ' This is a trapezoidal integration of bird density x risk across all values of height y
// '  Height is divided into (2 imax + 1) bands, the lowest being y=-1, the highest y=+1
// '  Height is converted to metres above sea level then used to find bird density at that level
//
// 'Application.Volatile
// 'Application.Calculation = xlCalculationAutomatic
//
// 'Dim i As Integer
// 'Dim imin As Integer
// 'Dim imax As Integer
// 'Dim total As Single
// 'Dim npoints As Integer
// 'Dim y As Single
// 'Dim radius As Single
// 'Dim hubheight As Single
// 'Dim offset As Single
// 'Dim dy As Single
// 'Dim prop As Single
// 'radius = Range("radius").Value
// 'hubheight = Range("hubheight").Value
// 'offset = Range("offset").Value
// 'npoints = Range("npoints").Value
//
// 'total = 0
//
// 'imin = Int(hubheight + offset - radius + 0.5)
// 'imax = Int(hubheight + offset + radius + 0.5)
//
// 'MsgBox imin, vbInformation, "imin"
// 'MsgBox imax, vbInformation, "imax"
//
// '  remember (i+1)'th cell in range is for i metres ie i-0.5 metres to i+0.5 metres
//
// 'Find bird density at lowest rotor point then calculate risk
// '    dy = Range("flightheightdata").Cells(imin + 1, 2)
// '    prop = (imin + 0.5) - (hubheight + offset - radius)
// '   MsgBox imin, vbInformation, "imin"
// '   MsgBox prop, vbInformation, "propmin"
// '    If (flag = 1) Then
// '   MsgBox (imin - hubheight - offset) / radius, vbInformation, "arg"
// '       total = dy * prop * xareasum2((imin - hubheight - offset) / radius)
// '
// '   Else
// '        total = dy * prop * xrisksum2((imin - hubheight - offset) / radius, xinc, updown)
// '    End If
//
// '   MsgBox imax, vbInformation, "imax"
// 'Find bird density at highest rotor point, then add in risk
// '    dy = Range("flightheightdata").Cells(imax + 1, 2)
// '   prop = hubheight + offset + radius - (imax - 0.5)
// '   MsgBox prop, vbInformation, "propmax"
// '    If (flag = 1) Then
// '        total = total + dy * prop * xareasum2((imax - hubheight - offset) / radius)
// '    Else
// '        total = total + dy * prop * xrisksum2((imax - hubheight - offset) / radius, xinc, updown)
// '    End If
// '
// 'i = imin + 1
// '    Do While (i < imax)
// 'MsgBox i, vbInformation, "i"
// '    Find bird density at successive steps in height then add in risk
//
// '    dy = Range("flightheightdata").Cells(i + 1, 2)
// 'MsgBox dy, vbInformation, dy
// '       If (flag = 1) Then
// '            total = total + dy * xareasum2((i - hubheight - offset) / radius)
// '        Else
// '            total = total + dy * xrisksum2((i - hubheight - offset) / radius, xinc, updown)
// '        End If
// '            i = i + 1
// '
// 'ydistdiscretesum = total
// 'End Function
//
//
//
registerWebworker(async () => {});
